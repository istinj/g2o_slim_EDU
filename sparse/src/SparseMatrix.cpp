#include "SparseMatrix.h"

using namespace std;

namespace sparse {
SparseMatrix::SparseMatrix(){
   _num_rows = 0;
   _num_cols = 0;
}
SparseMatrix::SparseMatrix(int num_rows_, int num_cols_){
   _num_rows = num_rows_;
   _num_cols = num_cols_;
   _row_container.resize(num_rows_);
}
SparseMatrix::~SparseMatrix(){

}

void SparseMatrix::setElement(const int r_, const int c_, const float value_){
   if (r_ >= _num_rows || c_ >= _num_cols){
      cerr << RED << "Out of bound" << RESET << endl;
      return;
   }

   ColumnsMap& current_row = _row_container[r_];
   ColumnsMap::iterator it = current_row.find(c_);
   if (it==current_row.end()) {
      if (value_!=0.0f) {
         current_row.insert(std::make_pair(c_,value_));
      }
   } else {
      if (value_==0.0f)
         current_row.erase(it);
      else
         it->second = value_;
   }
}

void SparseMatrix::resetMatrix(void){
   for(int i = 0; i < _num_rows; ++i){
      _row_container[i].clear();
   }
   _num_cols = 0;
   _num_rows = 0;
}

void SparseMatrix::resize(const int new_rows_, const int new_cols_){
   _row_container.resize(new_rows_);
   //  TODO: what does this mean??
   //  for (int r = 0; r < _row_container.size(); r++){
   //    ColumnsMap& row = _row_container[r];
   //    ColumnsMap::iterator start_it = row.upper_bound(new_cols_-1);
   //    row.erase(start_it, row.end());
   //  }
   _num_cols = new_cols_;
   _num_rows = new_rows_;
}

bool SparseMatrix::isNonZeroElement(const int r_, const int c_) const {
   const ColumnsMap& curr_row = _row_container[r_];
   ColumnsMap::const_iterator it = curr_row.find(c_);
   if(it == curr_row.end())
      return false;
   return true;
}

float SparseMatrix::getElement(const int r_, const int c_) const{
   if (r_ >= _num_rows || c_ >= _num_cols){
      cerr << RED << "Out of bound" << RESET << endl;
      return 0.0;
   }
   const ColumnsMap& curr_row = _row_container[r_];
   ColumnsMap::const_iterator it = curr_row.find(c_);
   if(it == curr_row.end())
      return 0.0;
   return it->second;
}

void SparseMatrix::printElement(const int r_, const int c_) const {
   ColumnsMap current_row = _row_container[r_]; //! No copy through reference
   float value = getElement(r_, c_);
   cout << BOLDWHITE << "Element(" << r_ << "," << c_ << ")" << ":\t" << CYAN << value << RESET << endl;
}

void SparseMatrix::loadFromTXT(const std::string& path_to_file_){
   resetMatrix();

   cout << BOLDYELLOW << "\t" << "Opening file " << path_to_file_ << RESET << endl;
   fstream file(path_to_file_);

   //! Check the size of the matrix to load
   string line;
   int matrix_size = 0;
   float temp_num = 0.0f;
   getline(file, line);
   stringstream ss(line);
   while(ss >> temp_num)
      ++matrix_size;
   resize(matrix_size, matrix_size);

   file.close();
   file.open(path_to_file_);

   int i = 0;
   while(getline(file, line)){
      stringstream ss(line);
      for(int j = 0; j < matrix_size; ++j){
         ss >> temp_num;
         if(temp_num == 0.0f){
            continue;
         } else {
            setElement(i,j,temp_num);
         }
      }
      ++i;
   }
   cout << BOLDGREEN << "\t" << "Matrix of size (" << i << " x " << i << ") loaded successfully"  << RESET << endl;
}

//! Function to evaluate the fill-in of the cholesky matrix, row by row
bool SparseMatrix::evaluateScalarProdStructure(const ColumnsMap& row_1_,
      const ColumnsMap& row_2_, int max_pos_){
   ColumnsMap::const_iterator it_1 = row_1_.begin();
   ColumnsMap::const_iterator it_2 = row_2_.begin();
   while(it_1 != row_1_.end() && it_2 != row_2_.end()){
      int col_idx_1 = it_1->first;
      int col_idx_2 = it_2->first;
      if(col_idx_1 > max_pos_ || col_idx_2 > max_pos_)
         return false;
      if(col_idx_1 == col_idx_2)
         return true;
      if(col_idx_1 > col_idx_2)
         ++it_2;
      else if(col_idx_1 < col_idx_2)
         ++it_1;
   }
   return false;
}

//! Evaluates the value of the elements generated by the fill-in
float SparseMatrix::scalarProd(const ColumnsMap& row_1_,
      const ColumnsMap& row_2_, const int max_pos_){
   float value = 0.0;
   ColumnsMap::const_iterator it_1 = row_1_.begin();
   ColumnsMap::const_iterator it_2 = row_2_.begin();
   while(it_1 != row_1_.end() && it_2 != row_2_.end()){
      int col_idx_1 = it_1->first;
      int col_idx_2 = it_2->first;
      if(col_idx_1 > max_pos_ || col_idx_2 > max_pos_)
         return value;
      if(col_idx_1 == col_idx_2){
         value += it_1->second * it_2->second;
         ++it_1;
         ++it_2;
      }
      else if(col_idx_1 > col_idx_2)
         ++it_2;
      else if(col_idx_1 < col_idx_2)
         ++it_1;
   }
   return value;
}

//! Allocates the data structure for the cholesky dec of the sparse matrix,
//! considering the fill-in due to the decomposition, for future use
void SparseMatrix::evaluateCholeskyStructure(SparseMatrix& cholesky_){
   if(_num_cols != _num_rows){
      cerr << BOLDRED << "Error: matrix must be squared" << RESET << endl;
      return;
   }
   cholesky_ = SparseMatrix(_num_rows, _num_cols);
   //! Looping over rows
   for (int r = 0; r < _num_rows; ++r) {
      const ColumnsMap& current_row = _row_container[r];
      ColumnsMap& chol_current_row = cholesky_._row_container[r];
      if(current_row.empty())
         return;
      int starting_col_idx = current_row.begin()->first;
      for(int c = starting_col_idx; c <= r; ++c){
         bool not_empty = false;
         if(isNonZeroElement(r,c)){
            not_empty = true;
         } else {
            ColumnsMap& chol_upper_row = cholesky_._row_container[c];
            not_empty = evaluateScalarProdStructure(chol_current_row, chol_upper_row, c);
         }
         if(not_empty)
            chol_current_row.insert(make_pair(c, 1.0));
      }
   }
}

//! Allocates and fills in the cholesky matrix with actual values
void SparseMatrix::cholesky(SparseMatrix& cholesky_){
   if(_num_cols != _num_rows){
      cerr << BOLDRED << "Error: matrix must be squared" << RESET << endl;
      return;
   }

   cholesky_ = SparseMatrix(_num_rows, _num_cols);
   for (int r = 0; r < _num_rows; ++r) {
      const ColumnsMap& current_row = _row_container[r];
      ColumnsMap& chol_current_row = cholesky_._row_container[r];
      float diagonal_values[_num_rows];
      float inverse_diagonal_values[_num_rows];
      if(current_row.empty())
         return;
      int starting_col_idx = current_row.begin()->first;
      for (int c = starting_col_idx; c <= r; ++c) {
         float accumulator = 0.0;
         ColumnsMap& chol_upper_row = cholesky_._row_container[c];
         accumulator = getElement(r, c) - scalarProd(chol_current_row, chol_upper_row, c-1);
         float chol_curr_rc_value = 0.0;
         if (r == c) {
            if (accumulator > 0) {
               chol_curr_rc_value = sqrt(accumulator);
               diagonal_values[r] = chol_curr_rc_value;
               inverse_diagonal_values[r] = 1.0/chol_curr_rc_value;
            } else {
               return;
            }
         } else {
            chol_curr_rc_value = inverse_diagonal_values[c] * accumulator;
         }
         chol_current_row.insert(make_pair(c, chol_curr_rc_value));
      }
   }
}
} // end namespace
